{"version":3,"sources":["../../../../../src/commands/info/doctor/depedencies/explain.ts"],"names":["isSpawnResult","result","explainAsync","packageName","parameters","ora","args","stdout","stdio","succeed","JSON","parse","error","stderr","match","fail","message","warnAboutDeepDependenciesAsync","pkg","explanations","name","Log","debug","printExplanationsAsync","organizeExplanations","isValid","valid","invalid","explanation","push","warn","otherPkg","semver","satisfies","version","length","printInvalidPackages","log","formatPkg","map","join","versionColor"],"mappings":"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","sourcesContent":["import spawnAsync, { SpawnResult } from '@expo/spawn-async';\nimport chalk from 'chalk';\nimport semver from 'semver';\n\nimport Log from '../../../../log';\nimport { logNewSection } from '../../../../utils/ora';\nimport { RootNodePackage, VersionSpec } from './explain.types';\n\ntype TargetPackage = { name: string; version: VersionSpec };\n\nfunction isSpawnResult(result: any): result is SpawnResult {\n  return 'stderr' in result && 'stdout' in result && 'status' in result;\n}\n\n/** Spawn `npm explain [name] --json` and return the parsed JSON. Returns `null` if the requested package is not installed. */\nexport async function explainAsync(\n  packageName: string,\n  parameters: string[] = []\n): Promise<RootNodePackage[] | null> {\n  const ora = logNewSection(`Finding all copies of ${packageName}`);\n  const args = ['explain', packageName, ...parameters, '--json'];\n\n  try {\n    const { stdout } = await spawnAsync('npm', args, {\n      stdio: 'pipe',\n    });\n    ora.succeed(`Found all copies of ${packageName}`);\n\n    return JSON.parse(stdout);\n  } catch (error: any) {\n    if (isSpawnResult(error)) {\n      if (error.stderr.match(/npm ERR! No dependencies found matching/)) {\n        ora.succeed();\n        return null;\n      }\n    }\n    ora.fail(`Failed to find dependency tree for ${packageName}: ` + error.message);\n    throw error;\n  }\n}\n\nexport async function warnAboutDeepDependenciesAsync(pkg: TargetPackage) {\n  const explanations = await explainAsync(pkg.name);\n\n  if (!explanations) {\n    Log.debug(`No dependencies found for ${pkg.name}`);\n    return;\n  }\n  printExplanationsAsync(pkg, explanations);\n}\n\nexport function organizeExplanations(\n  pkg: TargetPackage,\n  {\n    explanations,\n    isValid,\n  }: {\n    explanations: RootNodePackage[];\n    isValid: (pkg: TargetPackage) => boolean;\n  }\n) {\n  const valid: RootNodePackage[] = [];\n  const invalid: RootNodePackage[] = [];\n\n  for (const explanation of explanations) {\n    const { name } = explanation;\n    if (name === pkg.name) {\n      if (isValid(explanation)) {\n        valid.push(explanation);\n      } else {\n        invalid.push(explanation);\n      }\n    } else {\n      // Should never happen\n      Log.warn(\n        `Found invalid case where the searched package name \"${name}\" doesn't match requested package name \"${pkg.name}\"`\n      );\n    }\n  }\n  return { valid, invalid };\n}\n\nexport async function printExplanationsAsync(pkg: TargetPackage, explanations: RootNodePackage[]) {\n  const { invalid } = organizeExplanations(pkg, {\n    explanations,\n    isValid(otherPkg) {\n      return semver.satisfies(otherPkg.version, pkg.version);\n    },\n  });\n\n  if (invalid.length > 0) {\n    printInvalidPackages(pkg, { explanations: invalid });\n  } else {\n    Log.log(chalk`  All copies of {bold ${pkg.name}} satisfy {green ${pkg.version}}`);\n  }\n}\n\nfunction printInvalidPackages(\n  pkg: TargetPackage,\n  { explanations }: { explanations: RootNodePackage[] }\n) {\n  Log.warn(`Expected package ${formatPkg(pkg, 'green')}`);\n  Log.warn(chalk`Found invalid:`);\n  Log.warn(explanations.map(explanation => '  ' + formatPkg(explanation, 'red')).join('\\n'));\n  Log.warn(chalk`  {dim (for more info, run: {bold npm why ${pkg.name}})}`);\n\n  // Log.log(invalid.map(explanation => explainNode(explanation)).join('\\n\\n'));\n}\n\nfunction formatPkg(pkg: TargetPackage, versionColor: string) {\n  return chalk`{bold ${pkg.name}}{cyan @}{${versionColor} ${pkg.version}}`;\n}\n"],"file":"explain.js"}